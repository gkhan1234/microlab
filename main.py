"""
ESP32 Environmental Monitoring System - Main Program

This program implements an environmental monitoring system using an ESP32 microcontroller.
It reads data from multiple sensors, formats it as JSON, and sends it to a Firebase
Realtime Database. Optionally, it can display the readings on an OLED display.

Hardware Requirements:
- ESP32 development board
- DHT11 temperature and humidity sensor (GPIO 4)
- LDR light sensor with voltage divider (GPIO 36)
- Soil moisture sensor (GPIO 39)
- Optional: SSD1306 OLED display (I2C: SDA GPIO 21, SCL GPIO 22)

Author: Generated by Cline
Date: March 25, 2025
"""

#===============================================================================
# IMPORTS
#===============================================================================
import time
import network
import machine
import dht
import ujson
import urequests
import gc
from machine import Pin, ADC, I2C
import ntptime

# Import configuration
import config

# Optional: Import display library if enabled
if config.DISPLAY_ENABLED:
    try:
        import ssd1306
    except ImportError:
        print("Warning: ssd1306 library not found. Display will be disabled.")
        config.DISPLAY_ENABLED = False

#===============================================================================
# GLOBAL VARIABLES
#===============================================================================
# Initialize sensors
dht_sensor = None
ldr_sensor = None
soil_sensor = None
oled = None

# Network status
wifi_connected = False
last_reading_time = 0
cached_readings = []

#===============================================================================
# INITIALIZATION FUNCTIONS
#===============================================================================
def initialize_system():
    """Initialize all system components."""
    print("Initializing ESP32 Environmental Monitoring System...")
    
    # Initialize sensors
    initialize_sensors()
    
    # Initialize WiFi
    connect_wifi()
    
    # Initialize display if enabled
    if config.DISPLAY_ENABLED:
        initialize_display()
    
    # Sync time with NTP server if connected
    if wifi_connected:
        try:
            ntptime.settime()
            print("Time synchronized with NTP server")
        except:
            print("Failed to sync time with NTP server")
    
    print("System initialization complete")

def initialize_sensors():
    """Initialize all sensor hardware."""
    global dht_sensor, ldr_sensor, soil_sensor
    
    try:
        # Initialize DHT11 sensor
        dht_sensor = dht.DHT11(Pin(config.DHT_PIN))
        print(f"DHT11 sensor initialized on pin {config.DHT_PIN}")
        
        # Initialize LDR sensor (analog)
        ldr_sensor = ADC(Pin(config.LDR_PIN))
        ldr_sensor.atten(ADC.ATTN_11DB)  # Full range: 0-3.3V
        print(f"LDR sensor initialized on pin {config.LDR_PIN}")
        
        # Initialize soil moisture sensor (analog)
        soil_sensor = ADC(Pin(config.SOIL_MOISTURE_PIN))
        soil_sensor.atten(ADC.ATTN_11DB)  # Full range: 0-3.3V
        print(f"Soil moisture sensor initialized on pin {config.SOIL_MOISTURE_PIN}")
    
    except Exception as e:
        print(f"Error initializing sensors: {e}")
        raise

def initialize_display():
    """Initialize the OLED display if enabled."""
    global oled
    
    try:
        # Initialize I2C with frequency parameter for better compatibility
        # The EPLZON 0.96" OLED uses SSD1306 driver and works with 3.3V-5V
        i2c = I2C(0, scl=Pin(config.DISPLAY_SCL_PIN), sda=Pin(config.DISPLAY_SDA_PIN), freq=400000)
        
        # Scan for I2C devices
        devices = i2c.scan()
        if len(devices) == 0:
            print("No I2C devices found, disabling display")
            config.DISPLAY_ENABLED = False
            return
        
        print(f"I2C devices found at addresses: {[hex(d) for d in devices]}")
        
        # Check if a specific I2C address is configured
        if hasattr(config, 'DISPLAY_I2C_ADDR'):
            oled_addr = config.DISPLAY_I2C_ADDR
            if oled_addr not in devices:
                print(f"Warning: Configured display address {hex(oled_addr)} not found")
                # Fall back to auto-detection
                oled_addr = 0x3C if 0x3C in devices else (0x3D if 0x3D in devices else devices[0])
        else:
            # The EPLZON 0.96" OLED with SSD1306 driver typically uses address 0x3C (60)
            # Try the most common address first (0x3C)
            oled_addr = 0x3C
            if oled_addr not in devices and 0x3D in devices:
                oled_addr = 0x3D
            elif oled_addr not in devices and 0x3D not in devices and devices:
                # If neither common address is found but devices exist, use the first one
                oled_addr = devices[0]
                print(f"Warning: Using uncommon I2C address: {hex(oled_addr)}")
            
        print(f"Using OLED display at address: {hex(oled_addr)}")
        
        # Initialize display (128x64 SSD1306) - EPLZON 0.96" OLED
        oled = ssd1306.SSD1306_I2C(128, 64, i2c, addr=oled_addr)
        
        # Display startup message - utilizing the high contrast of the EPLZON OLED
        oled.fill(0)  # Clear display (black background)
        
        # Center the title
        title = "ESP32 Monitor"
        title_x = (128 - len(title) * 8) // 2
        oled.text(title, title_x, 0)
        
        # Draw a line under the title
        oled.hline(0, 10, 128, 1)
        
        # Display initializing message
        oled.text("Initializing...", 10, 25)
        
        # Display version info
        oled.text("v1.0", 50, 40)
        
        # Update display
        oled.show()
        
        print("OLED display initialized successfully")
    
    except Exception as e:
        print(f"Error initializing display: {e}")
        config.DISPLAY_ENABLED = False

#===============================================================================
# NETWORK FUNCTIONS
#===============================================================================
def connect_wifi():
    """Connect to WiFi network using credentials from config."""
    global wifi_connected
    
    print(f"Connecting to WiFi network: {config.WIFI_SSID}")
    
    # Initialize WiFi in station mode
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    
    if not wlan.isconnected():
        # Connect to the network
        wlan.connect(config.WIFI_SSID, config.WIFI_PASSWORD)
        
        # Wait for connection with timeout
        max_wait = 20
        while max_wait > 0:
            if wlan.isconnected():
                break
            max_wait -= 1
            print("Waiting for connection...")
            time.sleep(1)
    
    # Check if connected
    if wlan.isconnected():
        wifi_connected = True
        network_info = wlan.ifconfig()
        print(f"Connected to WiFi. IP address: {network_info[0]}")
    else:
        wifi_connected = False
        print("Failed to connect to WiFi")
    
    return wifi_connected

def check_wifi_connection():
    """Check if WiFi is still connected and attempt to reconnect if not."""
    global wifi_connected
    
    wlan = network.WLAN(network.STA_IF)
    
    if not wlan.isconnected():
        print("WiFi connection lost. Attempting to reconnect...")
        wifi_connected = False
        
        # Try to reconnect
        connect_wifi()
    
    return wifi_connected

def send_to_firebase(data):
    """Send data to Firebase Realtime Database."""
    if not wifi_connected:
        print("Cannot send data: WiFi not connected")
        return False
    
    try:
        # Construct the URL for the Firebase endpoint
        url = f"{config.FIREBASE_URL}/readings/{config.DEVICE_ID}.json"
        if config.FIREBASE_SECRET:
            url += f"?auth={config.FIREBASE_SECRET}"
        
        # Send the data
        print(f"Sending data to Firebase: {data}")
        response = urequests.post(url, data=ujson.dumps(data))
        
        # Check response
        if response.status_code == 200:
            print("Data sent successfully")
            response.close()
            return True
        else:
            print(f"Failed to send data. Status code: {response.status_code}")
            response.close()
            return False
    
    except Exception as e:
        print(f"Error sending data to Firebase: {e}")
        return False

def send_cached_readings():
    """Attempt to send any cached readings that failed to send previously."""
    global cached_readings
    
    if not wifi_connected or not cached_readings:
        return
    
    print(f"Attempting to send {len(cached_readings)} cached readings")
    
    # Try to send each cached reading
    successful_indices = []
    for i, reading in enumerate(cached_readings):
        if send_to_firebase(reading):
            successful_indices.append(i)
    
    # Remove successfully sent readings (in reverse order to avoid index issues)
    for i in sorted(successful_indices, reverse=True):
        cached_readings.pop(i)
    
    print(f"{len(successful_indices)} cached readings sent, {len(cached_readings)} remaining")

#===============================================================================
# SENSOR READING FUNCTIONS
#===============================================================================
def read_temperature_humidity():
    """Read temperature and humidity from DHT11 sensor."""
    if dht_sensor is None:
        return None, None
    
    try:
        # Measure from DHT sensor
        dht_sensor.measure()
        temperature = dht_sensor.temperature()
        humidity = dht_sensor.humidity()
        
        print(f"Temperature: {temperature}Â°C, Humidity: {humidity}%")
        return temperature, humidity
    
    except Exception as e:
        print(f"Error reading DHT11 sensor: {e}")
        return None, None

def read_light_level():
    """Read light level from LDR sensor."""
    if ldr_sensor is None:
        return None
    
    try:
        # Read raw ADC value
        raw_value = ldr_sensor.read()
        
        # Convert to percentage (0-100%)
        light_percent = ((raw_value - config.LDR_MIN) * 100) / (config.LDR_MAX - config.LDR_MIN)
        light_percent = max(0, min(100, light_percent))  # Clamp between 0-100%
        
        print(f"Light level: {light_percent:.1f}% (raw: {raw_value})")
        return light_percent
    
    except Exception as e:
        print(f"Error reading LDR sensor: {e}")
        return None

def read_soil_moisture():
    """Read soil moisture from soil moisture sensor."""
    if soil_sensor is None:
        return None
    
    try:
        # Read raw ADC value
        raw_value = soil_sensor.read()
        
        # Convert to percentage (0-100%)
        # Note: For most soil sensors, higher value means lower moisture
        # So we invert the percentage calculation
        moisture_percent = 100 - ((raw_value - config.SOIL_MIN) * 100) / (config.SOIL_MAX - config.SOIL_MIN)
        moisture_percent = max(0, min(100, moisture_percent))  # Clamp between 0-100%
        
        print(f"Soil moisture: {moisture_percent:.1f}% (raw: {raw_value})")
        return moisture_percent
    
    except Exception as e:
        print(f"Error reading soil moisture sensor: {e}")
        return None

def read_all_sensors():
    """Read data from all sensors and return as a dictionary."""
    # Read sensor values
    temperature, humidity = read_temperature_humidity()
    light_level = read_light_level()
    soil_moisture = read_soil_moisture()
    
    # Create data dictionary
    data = {
        "device_id": config.DEVICE_ID,
        "timestamp": time.time(),
        "readings": {
            "temperature": temperature,
            "humidity": humidity,
            "light_level": light_level,
            "soil_moisture": soil_moisture
        }
    }
    
    return data

#===============================================================================
# DISPLAY FUNCTIONS
#===============================================================================
def update_display(data):
    """Update the OLED display with current sensor readings."""
    if not config.DISPLAY_ENABLED or oled is None:
        return
    
    try:
        # Clear the display - EPLZON OLED has excellent contrast with black background
        oled.fill(0)
        
        # Display title (centered for 128px width)
        title = "ESP32 Monitor"
        title_x = (128 - len(title) * 8) // 2  # Center text (assuming 8px per char)
        oled.text(title, title_x, 0)
        
        # Draw a line under the title - utilizing the high resolution
        oled.hline(0, 10, 128, 1)
        
        # Display readings
        readings = data.get("readings", {})
        
        # Draw small icons/symbols for each reading type
        # Temperature icon (thermometer-like symbol)
        oled.rect(4, 16, 3, 8, 1)  # Thermometer bulb
        oled.pixel(5, 15, 1)       # Top of thermometer
        
        # Humidity icon (water droplet-like symbol)
        oled.pixel(4, 28, 1)
        oled.pixel(5, 27, 1)
        oled.pixel(6, 28, 1)
        oled.pixel(5, 29, 1)
        
        # Light icon (sun-like symbol)
        oled.pixel(75, 16, 1)
        oled.pixel(73, 16, 1)
        oled.pixel(77, 16, 1)
        oled.pixel(75, 14, 1)
        oled.pixel(75, 18, 1)
        
        # Soil moisture icon (plant-like symbol)
        oled.pixel(75, 28, 1)
        oled.pixel(75, 29, 1)
        oled.pixel(74, 27, 1)
        oled.pixel(76, 27, 1)
        
        # Column 1 (left side) - readings with units
        if readings.get("temperature") is not None:
            oled.text(f"{readings['temperature']}C", 10, 16)
        
        if readings.get("humidity") is not None:
            oled.text(f"{readings['humidity']}%", 10, 28)
        
        # Column 2 (right side) - readings with units
        if readings.get("light_level") is not None:
            oled.text(f"{readings['light_level']:.0f}%", 80, 16)
        
        if readings.get("soil_moisture") is not None:
            oled.text(f"{readings['soil_moisture']:.0f}%", 80, 28)
        
        # Draw another line
        oled.hline(0, 40, 128, 1)
        
        # Display WiFi status with a small icon
        if wifi_connected:
            # WiFi icon (connected)
            oled.pixel(4, 48, 1)
            oled.pixel(6, 48, 1)
            oled.pixel(5, 47, 1)
            oled.text("Connected", 10, 48)
        else:
            # WiFi icon (disconnected)
            oled.pixel(4, 48, 1)
            oled.pixel(6, 48, 1)
            oled.line(3, 49, 7, 45, 1)  # Diagonal line through icon
            oled.text("Offline", 10, 48)
        
        # Display timestamp at bottom
        current_time = time.localtime(time.time())
        time_str = f"{current_time[3]:02d}:{current_time[4]:02d}"
        time_x = 128 - len(time_str) * 8 - 2  # Right-aligned
        oled.text(time_str, time_x, 54)
        
        # Update display
        oled.show()
    
    except Exception as e:
        print(f"Error updating display: {e}")
        # Try to recover display if possible
        try:
            initialize_display()
        except:
            pass

def display_error(message):
    """Display an error message on the OLED display."""
    if not config.DISPLAY_ENABLED or oled is None:
        return
    
    try:
        # Clear the display - EPLZON OLED has excellent contrast with black background
        oled.fill(0)
        
        # Draw error icon (X symbol) in top left
        oled.line(2, 2, 8, 8, 1)
        oled.line(2, 8, 8, 2, 1)
        
        # Display error title (centered)
        title = "ERROR"
        title_x = (128 - len(title) * 8) // 2
        oled.text(title, title_x, 0)
        
        # Draw a line under the title
        oled.hline(0, 10, 128, 1)
        
        # Create a border around the error message area
        oled.rect(0, 15, 128, 40, 1)
        
        # Display error message (split into multiple lines if needed)
        words = message.split()
        line = ""
        y_pos = 20  # Start position after the title and inside the border
        
        for word in words:
            # Check if adding this word would exceed display width
            if len(line + word) + 1 > 15:  # Slightly reduced width due to border
                oled.text(line, 5, y_pos)  # Indent text from border
                y_pos += 10  # Move to next line
                line = word
                
                # Check if we've run out of display space
                if y_pos > 45:
                    break
            else:
                if line:
                    line += " " + word
                else:
                    line = word
        
        # Display the last line if there's space
        if line and y_pos <= 45:
            oled.text(line, 5, y_pos)
        
        # Draw a "Retry" message at the bottom
        oled.text("System will retry...", 5, 56)
        
        # Update display
        oled.show()
    
    except Exception as e:
        print(f"Error displaying error message: {e}")

#===============================================================================
# MAIN PROGRAM LOOP
#===============================================================================
def main():
    """Main program loop."""
    global last_reading_time, cached_readings
    
    try:
        # Initialize the system
        initialize_system()
        
        print("Starting main loop...")
        
        while True:
            current_time = time.time()
            
            # Check if it's time to take a reading
            if current_time - last_reading_time >= config.READING_INTERVAL:
                # Check WiFi connection
                check_wifi_connection()
                
                # Read sensor data
                data = read_all_sensors()
                
                # Update display
                update_display(data)
                
                # Try to send data to Firebase
                if wifi_connected:
                    # First try to send any cached readings
                    send_cached_readings()
                    
                    # Then send current reading
                    if not send_to_firebase(data):
                        # If failed, add to cache
                        cached_readings.append(data)
                        print(f"Data added to cache. Cache size: {len(cached_readings)}")
                else:
                    # If not connected, add to cache
                    cached_readings.append(data)
                    print(f"WiFi not connected. Data added to cache. Cache size: {len(cached_readings)}")
                
                # Limit cache size to prevent memory issues
                if len(cached_readings) > 50:
                    cached_readings = cached_readings[-50:]
                    print("Cache size limited to 50 entries")
                
                # Update last reading time
                last_reading_time = current_time
                
                # Run garbage collection to free memory
                gc.collect()
            
            # Small delay to prevent busy waiting
            time.sleep(1)
    
    except KeyboardInterrupt:
        print("Program terminated by user")
    
    except Exception as e:
        print(f"Unhandled exception in main loop: {e}")
        display_error(f"System error: {e}")
        
        # Try to restart after a delay
        time.sleep(10)
        machine.reset()

# Start the program
if __name__ == "__main__":
    main()
